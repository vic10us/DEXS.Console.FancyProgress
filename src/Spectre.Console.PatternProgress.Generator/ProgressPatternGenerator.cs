using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Text.Json;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;

namespace Spectre.Console.PatternProgress.Generator;

[Generator]
public class ProgressPatternGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var jsonFiles = context.AdditionalTextsProvider
            .Where(file => Path.GetFileName(file.Path) == "progressPatterns.json");

        var patternsProvider = jsonFiles.Select((file, cancellationToken) =>
        {
            var text = file.GetText(cancellationToken)?.ToString();
            if (string.IsNullOrWhiteSpace(text))
                return null;
            try
            {
                var opts = new JsonSerializerOptions { PropertyNameCaseInsensitive = true };
                return JsonSerializer.Deserialize<Dictionary<string, ProgressPatternJson>>(text, opts);
            }
            catch
            {
                return null;
            }
        });

        context.RegisterSourceOutput(patternsProvider, (spc, patterns) =>
        {
            if (patterns == null)
                return;

            var sb = new StringBuilder();
            // Add auto-generated header
            sb.AppendLine("""
                //------------------------------------------------------------------------------
                // <auto-generated>
                //     This code was generated by a tool.
                //
                //     Partly generated from
                //     progressPatterns.json
                //
                //     Changes to this file may cause incorrect behavior and will be lost if
                //     the code is regenerated.
                // </auto-generated>
                //------------------------------------------------------------------------------
                
                namespace Spectre.Console.PatternProgress;

                /// <summary>
                /// Represents a progress bar pattern. This class is auto-generated from progressPatterns.json.
                /// </summary>
                public abstract partial class ProgressPattern {
                """);

            foreach (var kvp in patterns)
            {
                var name = ToPascalCase(kvp.Key) + "ProgressPattern";
                var charLiterals = string.Join(", ", kvp.Value.pattern.Select(p => ToCharLiteral(p)));
                bool isUnicode = kvp.Value.pattern.Any(p => !string.IsNullOrEmpty(p) && p[0] > 127);

                sb.AppendLine($$"""
                
                    /// <summary>
                    /// Pattern for '{{kvp.Key}}'.
                    /// </summary>
                    private sealed class {{name}} : ProgressPattern {
                        /// <inheritdoc/>
                        public override string Name => "{{kvp.Key}}";
                        /// <inheritdoc/>
                        public override IReadOnlyList<char> Pattern => new[] { {{charLiterals}} };
                        /// <inheritdoc/>
                        public override bool IsUnicode => {{(isUnicode ? "true" : "false")}};
                        /// <inheritdoc/>
                        public override bool IsCursor => {{(kvp.Value.isCursor ? "true" : "false")}};
                    }
                 """);
            }

            sb.AppendLine("""

                    /// <summary>
                    /// Provides access to known progress bar patterns.
                    public static class Known {
                """);

            foreach (var kvp in patterns)
            {
                sb.AppendLine($$"""

                        /// <summary>
                        /// Gets the '{{kvp.Key}}' progress pattern.
                        /// </summary>
                        public static ProgressPattern {{ToPascalCase(kvp.Key)}} { get; } = new {{ToPascalCase(kvp.Key) + "ProgressPattern"}}();
                """);
            }

            var defaultPattern = patterns.FirstOrDefault(p => p.Value.isDefault).Key;
            if (!string.IsNullOrEmpty(defaultPattern))
            {
                sb.AppendLine($$"""
                        
                        /// <summary>
                        /// Gets the default progress pattern.
                        /// </summary>
                        public static ProgressPattern Default { get; } = new {{ToPascalCase(defaultPattern)}}ProgressPattern();

                """);
            }

            sb.AppendLine("""
                    /// <summary>
                    /// Gets all known progress patterns.
                    /// </summary>
                    /// <value></value>
                    public static ProgressPattern[] AllPatterns { get; } = new[] {
            """);

            foreach (var kvp in patterns)
            {
                sb.AppendLine($"            {ToPascalCase(kvp.Key)},");
            }

            sb.AppendLine("""
                    };
                }
            }
            """);

            spc.AddSource("ProgressPattern.Generated.cs", SourceText.From(sb.ToString(), Encoding.UTF8));

            // Emit a test file to confirm generator is running
            spc.AddSource("__GeneratorTest.cs", SourceText.From("// Generator is running!", Encoding.UTF8));
        });
    }

    private static string ToPascalCase(string s)
    {
        if (string.IsNullOrEmpty(s)) return s;
        return char.ToUpperInvariant(s[0]) + s.Substring(1);
    }

    private static string ToCharLiteral(string s)
    {
        if (string.IsNullOrEmpty(s) || s.Length != 1)
            throw new ArgumentException($"Pattern entry '{s}' is not a single character.");
        var c = s[0];
        switch (c)
        {
            case '\\': return "'\\\\'";
            case '\'': return "'\\\''";
            case '"': return "'\\\"'";
            default:
                if (char.IsControl(c) || char.IsWhiteSpace(c) || c > 127)
                    return $"'\\u{(int)c:x4}'";
                return $"'{c}'";
        }
    }

    private class ProgressPatternJson
    {
        public bool isDefault { get; set; }
        public bool isCursor { get; set; }
        public List<string> pattern { get; set; }
    }
}
